// compile with: -std=c99
#include <stdio.h>
#include <malloc.h>

int main()
{
	///////////////////////////////////////
	// 指针
	///////////////////////////////////////

	// 指针变量是用来储存内存地址的变量
	// 指针变量的声明也会告诉它所指向的数据的类型
	// 你可以使用得到你的变量的地址，并把它们搞乱，;-)

	int x = 0;
	printf("%p\n", &x); // 用 & 来获取变量的地址
	// (%p 格式化一个类型为 void *的指针)
	// => 打印某个内存地址

	// 指针类型在声明中以*开头
	int* px = NULL,
		not_a_pointer = 0; // px是一个指向int型的指针
	px = &x; // 把x的地址保存到px中
	printf("%p\n", (void *) px); // => 输出内存中的某个地址
	printf("%lu, %lu\n", sizeof(px), sizeof(not_a_pointer));
	// => 在64位系统上打印“8， 4”。

	// 要得到某个指针指向的内容的值，可以在指针前加一个*来取得（取消引用）
	// 注意： 是的，这可能让人困惑，'*'在用来声明一个指针的同时取消引用它。
	printf("%d\n", *px); // => 输出 0, 即x的值

	// 你也可以改变指针所指向的值
	// 此时你需要取消引用上添加括号，因为++比*的优先级更高
	(*px)++; // 把px所指向的值增加1
	printf("%d\n", *px); // => 输出 1
	printf("%d\n", x); // => 输出 1

	// 数组是分配一系列连续空间的常用方式
	int x_array[20] = {0};
	for (int xx = 0; xx<20; xx++) 
	{
		x_array[xx] = 20 - xx;
	} // 初始化 x_array 为 20, 19, 18,... 2, 1

	// 声明一个整型的指针，并初始化为指向x_array
	int* x_ptr = x_array;
	// x_ptr现在指向了数组的第一个元素(即整数20). 
	// 这是因为数组通常衰减为指向它们的第一个元素的指针。
	// 例如，当一个数组被传递给一个函数或者绑定到一个指针时，
	// 它衰减为(隐式转化为）一个指针。
	// 例外： 当数组是`&`操作符的参数：
	int arr[10] = {0};
	int(*ptr_to_arr)[10] = &arr; // &arr的类型不是`int *`！
	// 它的类型是指向数组的指针（数组由10个int组成）
	// 或者当数组是字符串字面量（初始化字符数组）
	char c_arr [] = "foobarbazquirk";
	// 或者当它是`sizeof`或`alignof`操作符的参数时：
	int i_arr[10] = {0};
	int *ptr = i_arr; // 等价于 int *ptr2 = arr[0];
	printf("%lu, %lu, %lu\n", sizeof i_arr, sizeof ptr, sizeof *ptr); // 应该会输出"40, 4, 4"或"40, 8, 4"

	// 指针的增减多少是依据它本身的类型而定的
	// （这被称为指针算术）
	printf("%d\n", *(x_ptr + 1)); // => 打印 19
	printf("%d\n", x_array[1]); // => 打印 19

	// 你也可以通过标准库函数malloc来实现动态分配
	// 这个函数接受一个代表容量的参数，参数类型为`size_t`
	// 系统一般会从堆区分配指定容量字节大小的空间
	// （在一些系统，例如嵌入式系统中这点不一定成立
	// C标准对此未置一词。）
	int *my_ptr = malloc(sizeof(*my_ptr) * 20);
	for (int xx = 0; xx<20; xx++) {
		*(my_ptr + xx) = 20 - xx; // my_ptr[xx] = 20-xx
	} // 初始化内存为 20, 19, 18, 17... 2, 1 (类型为int）

	// 对未分配的内存进行取消引用会产生未定义的结果
	printf("%d\n", *(my_ptr + 21)); // => 谁知道会输出什么

	// malloc分配的区域需要手动释放
	// 否则没人能够再次使用这块内存，直到程序结束为止
	free(my_ptr);

	// 字符串通常是字符数组，但是经常用字符指针表示
	// (它是指向数组的第一个元素的指针)
	// 一个优良的实践是使用`const char *`来引用一个字符串字面量，
	// 因为字符串字面量不应当被修改（即"foo"[0] = 'a'犯了大忌）
	const char* my_str = "This is my very own string";
	printf("%c\n", *my_str); // => 'T'

	// 如果字符串是数组，（多半是用字符串字面量初始化的）
	// 情况就不一样了，字符串位于可写的内存中
	char foo [] = "foo";
	foo[0] = 'a'; // 这是合法的，foo现在包含"aoo"

	return 0;
}
